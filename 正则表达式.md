# 正则表达式

正则表达式（Regular expressions，也叫 REs、 regexs 或 regex patterns），本质上是嵌入 Python 内部并通过 [`re`](https://docs.python.org/zh-cn/3/library/re.html#module-re) 模块提供的一种微小的、高度专业化的编程语言。使用这种小语言，你可以为想要匹配的可能字符串编写规则；这些字符串可能是英文句子、邮箱地址、TeX 命令或任何你喜欢的内容。然后，你可以提出诸如“此字符串是否与表达式匹配？”、“字符串中是否存在表达式的匹配项？”之类的问题。你还可以用正则来修改字符串，或以各种方式将其拆分。

正则表达式会被编译成一系列字节码，然后由 C 语言编写的匹配引擎执行。对于高级用途，可能有必要特别注意引擎将如何执行一个给定的正则，并以某种方式写入正则，以生成运行更快的字节码。本文不涉及优化问题，因为这要求你对正则引擎的匹配过程有很好的了解。

正则表达式语言相对较小且受限，因此并非所有可能的字符串处理任务都可以使用正则表达式完成。有些任务尽管*可以*用正则表达式来完成，但表达式会变得非常复杂。这些情况下，最好通过编写 Python 代码来进行处理。也许 Python 代码会比精心设计的正则表达式慢，但它可能更容易理解。

## 匹配字符

```python
这是元字符的完整列表
. ^ $ * + ? { } [ ] \ | ( )

首先介绍的元字符是 [ 和 ] 。这两个元字符用于指定一个字符类，也就是你希望匹配的字符的一个集合。这些字符可以单独地列出，也可以用字符范围来表示（给出两个字符并用 '-' 分隔）。例如，[abc] 将匹配 a、b、c 之中的任意一个字符；这与 [a-c] 相同，后者使用一个范围来表达相同的字符集合。如果只想匹配小写字母，则正则表达式将是 [a-z] 。

元字符 (除了 \) 在字符类中是不起作用的。 例如，[akm$] 将会匹配以下任一字符 'a', 'k', 'm' 或 '$'；'$' 通常是一个元字符，但在一个字符类中它的特殊性被消除了。

你可以通过对集合 取反 来匹配字符类中未列出的字符。方法是把 '^' 放在字符类的最开头。 例如，[^5] 将匹配除 '5' 之外的任何字符。 如果插入符出现在字符类的其他位置，则它没有特殊含义。 例如：[5^] 将匹配 '5' 或 '^'。

也许最重要的元字符是反斜杠，\ 。 与 Python 字符串字面量一样，反斜杠后面可以跟各种字符来表示各种特殊序列。它还用于转义元字符，以便可以在表达式中匹配元字符本身。例如，如果需要匹配一个 [ 或 \ ，可以在其前面加上一个反斜杠来消除它们的特殊含义：\[ 或 \\ 。

一些以 '\' 开头的特殊序列表示预定义的字符集合，这些字符集通常很有用，例如数字集合、字母集合或非空白字符集合。

让我们举一个例子：\w 匹配任何字母数字字符。 如果正则表达式以 bytes 类型表示，\w 相当于字符类 [a-zA-Z0-9_] 。如果正则表达式是 str 类型，\w 将匹配由 unicodedata 模块提供的 Unicode 数据库中标记为字母的所有字符。 通过在编译正则表达式时提供 re.ASCII 标志，可以在 str 表达式中使用较为狭窄的 \w 定义。

以下为特殊序列的不完全列表。 有关 Unicode 字符串正则表达式的序列和扩展类定义的完整列表，参见标准库参考中 正则表达式语法 的最后一部分 。通常，Unicode 版本的字符类会匹配 Unicode 数据库的相应类别中的任何字符。

\d
匹配任何十进制数字，等价于字符类 [0-9] 。

\D
匹配任何非数字字符，等价于字符类 [^0-9] 。

\s
匹配任何空白字符，等价于字符类 [ \t\n\r\f\v] 。

\S
匹配任何非空白字符，等价于字符类 [^ \t\n\r\f\v] 。

\w
匹配任何字母与数字字符，等价于字符类 [a-zA-Z0-9_] 。

\W
匹配任何非字母与数字字符，等价于字符类 [^a-zA-Z0-9_] 。

这些序列可以包含在字符类中。 例如，[\s,.] 是一个匹配任何空白字符、',' 或 '.' 的字符类。

本节的最后一个元字符是 . 。 它匹配除换行符之外的任何字符，并且有一个可选模式（ re.DOTALL ），在该模式下它甚至可以匹配换行符。 . 通常用于你想匹配“任何字符”的场景。
```

## 重复

```python
能够匹配各种各样的字符集合是正则表达式可以做到的第一件事，而这是字符串方法所不能做到的。但是，如果正则表达式就只有这么一个附加功能，它很难说的上有多大优势。另一个功能是，你可以指定正则的某部分必须重复一定的次数。

我们先来说说重复元字符 * 。 * 并不是匹配一个字面字符 '*' 。实际上，它指定前一个字符可以匹配零次或更多次，而不是只匹配一次。

例如，ca*t 将匹配 'ct' （ 0 个 'a' ）、'cat' （ 1 个 'a' ）、 'caaat' （ 3 个 'a' ）等等。

类似 * 这样的重复是 贪婪的 。当重复正则时，匹配引擎将尝试重复尽可能多的次数。 如果表达式的后续部分不匹配，则匹配引擎将回退并以较少的重复次数再次尝试。

另一个重复元字符是 + ，表示匹配一次或更多次。请注意 * 与 + 之间的差别。 * 表示匹配 零次 或更多次，也就是说它所重复的内容是可以完全不出现的。而 + 则要求至少出现一次。举一个类似的例子， ca+t 可以匹配 'cat' （ 1 个 'a' ）或 'caaat' （ 3 个 'a'），但不能匹配 'ct' 。

此外还有两个重复操作符或限定符。 问号 ? 表示匹配一次或零次；你可以认为它把某项内容变成了可选的。 例如，home-?brew 可以匹配 'homebrew' 或 'home-brew'。

最复杂的限定符是 {m,n}，其中 m 和 n 都是十进制整数。 该限定符表示必须至少重复 m 次，至多重复 n 次。 例如，a/{1,3}b 将匹配 'a/b', 'a//b' 和 'a///b'。 它不能匹配 'ab'，因为其中没有斜杠，也不能匹配 'a////b'，因为其中有四个斜杠。

m 和 n 不是必填的，缺失的情况下会设定为默认值。缺失 m 会解释为最少重复 0 次 ，缺失 n 则解释为最多重复无限次。

细心的读者可能会注意到另外三个限定符都可以使用此标记法来表示。 {0,} 等同于 *, {1,} 等同于 +, 而 {0,1} 等同于 ?。 在可能的情况下使用 *, + 或 ? 会更好，因为它们更为简短易读。
```

